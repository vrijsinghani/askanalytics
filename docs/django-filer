django-filer 3.3.1 documentation django-filer 3.3.1 documentation Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Welcome to django-filerâ€™s documentation!Â¶ django-filer is a file management application for django. It handles uploading and organizing files and images in contrib.admin. Filer detail view: Filer picker widget: Custom model fields are provided for use in 3rd party apps as a replacement for the default FileField from django. Behind the scenes a ForeignKey to the File model is used. Getting helpÂ¶ google group: http://groups.google.com/group/django-filer IRC: #django-filer on freenode.net ContributingÂ¶ The code is hosted on github at http://github.com/divio/django-filer/ and is fully open source. We hope you choose to help us on the project! More information on how to contribute can be found in contributing. ContentsÂ¶ Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Next Installation and Configuration Copyright Â© 2025, Stefan Foulis | Built with Sphinx and @pradyunsg's Furo theme. | Show Source Contents Welcome to django-filerâ€™s documentation! Getting help Contributing Contents

django-filer 3.3.1 documentation Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Installation and Configuration Getting the latest release The easiest way to get django-filer is simply install it with pip: $ pip install django-filer Optional heic support Currently, django-filer supports upload of heif images (*.heic, such as retrieved from iOS devices by airdrop) using an optional dependency: $ pip install django-filer\[heif\] Dependencies Django >= 3.2 easy_thumbnails >= 2.0 django-polymorphic >= 3.0 Pillow >=2.3.0 (with JPEG and ZLIB support, PIL may work but is not supported) django.contrib.staticfiles is required. Please make sure you install Pillow with JPEG and ZLIB support installed; for further information on Pillow installation and its binary dependencies, check Pillow doc. If heif support is chosen, django-filer also installs pillow-heif Configuration Add "filer" and related apps to your projectâ€™s INSTALLED_APPS setting and run manage.py migrate: INSTALLED_APPS = [ ... 'easy_thumbnails', 'filer', ... ] Note that easy_thumbnails also has database tables and needs a python manage.py migrate. Static media django-filer javascript and css files are managed by django.contrib.staticfiles; please see staticfiles documentation to know how to deploy filer static files in your environment. Subject location aware cropping It is possible to define the important part of an image (the subject location) in the admin interface for django-filer images. This is very useful when later resizing and cropping images with easy_thumbnails. The image can then be cropped automatically in a way, that the important part of the image is always visible. To enable automatic subject location aware cropping of images replace easy_thumbnails.processors.scale_and_crop with filer.thumbnail_processors.scale_and_crop_with_subject_location in the THUMBNAIL_PROCESSORS setting: THUMBNAIL_PROCESSORS = ( 'easy_thumbnails.processors.colorspace', 'easy_thumbnails.processors.autocrop', #'easy_thumbnails.processors.scale_and_crop', 'filer.thumbnail_processors.scale_and_crop_with_subject_location', 'easy_thumbnails.processors.filters', ) To crop an image and respect the subject location: {% load thumbnail %} {% thumbnail obj.img 200x300 crop upscale subject_location=obj.img.subject_location %} Permissions Warning File permissions are an experimental feature. The api may change at any time. See Permissions section. Secure downloads Warning File download permissions are an experimental feature. The api may change at any time. See Secure Downloads section. Canonical URLs You can configure your project to generate canonical URLs for your public files. Just include django-filerâ€™s URLConf in your projectâ€™s urls.py: urlpatterns = [ ... url(r'^filer/', include('filer.urls')), ... ] Contrary to the fileâ€™s actual URL, the canonical URL does not change if you upload a new version of the file. Thus, you can safely share the canonical URL. As long as the file exists, people will be redirected to its latest version. The canonical URL is displayed in the â€œadvancedâ€ panel on the fileâ€™s admin page. It has the form: /filer/canonical/1442488644/12/ The â€œfilerâ€ part of the URL is configured in the projectâ€™s URLconf as described above. The â€œcanonicalâ€ part can be changed with the setting FILER_CANONICAL_URL, which defaults to 'canonical/'. Example: # settings.py FILER_CANONICAL_URL = 'sharing/' Debugging and logging While by default django-filer usually silently skips icon/thumbnail generation errors, two options are provided to help when working with django-filer: FILER_DEBUG: Boolean, controls whether bubbling up any easy-thumbnails exception (typically if an image file doesnâ€™t exists); is False by default; FILER_ENABLE_LOGGING: Boolean, controls whether logging the above exceptions. It requires proper django logging configuration for default logger or filer logger. Please see https://docs.djangoproject.com/en/dev/topics/logging/ for further information about Djangoâ€™s logging configuration. Document Extraction for Developers Transform docs into structured data with Sensible. Try for free â†’ Ads by EthicalAds Next Upgrading Previous Home Copyright Â© 2025, Stefan Foulis | Built with Sphinx and @pradyunsg's Furo theme. | Show Source CONTENTS Getting the latest release Optional heic support Dependencies Configuration Static media Subject location aware cropping Permissions Secure downloads Canonical URLs Debugging and logging

django-filer 3.3.1 documentation Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Usage django-filer provides model fields to replace djangos own django.db.models.FileField and django.db.models.ImageField. The django-filer versions provide the added benefit of being able to manage the files independently of where they are actually used in your content. As such the same file can be used in multiple places without re-uploading it multiple times and wasting bandwidth, time and storage. It also comes with additional tools to detect file duplicates based on SHA1 checksums. Note behind the scenes this field is actually just a ForeignKey to the File model in django-filer. So you can easily access the extra metadata like this: company.disclaimer.sha1 company.disclaimer.size company.logo.width company.logo.height company.logo.icons['64'] # or {{ company.logo.icons.64 }} in a template company.logo.url # prints path to original image FilerFileField and FilerImageField They are subclasses of django.db.models.ForeignKey, so the same rules apply. The only difference is, that there is no need to declare what model we are referencing (it is always filer.models.File for the FilerFileField and filer.models.Image for the FilerImageField). Simple example models.py: from django.db import models from filer.fields.image import FilerImageField from filer.fields.file import FilerFileField class Company(models.Model): name = models.CharField(max_length=255) logo = FilerImageField(null=True, blank=True, related_name="logo_company", on_delete=models.SET_NULL) disclaimer = FilerFileField(null=True, blank=True, related_name="disclaimer_company", on_delete=models.SET_NULL) multiple file fields on the same model: from django.db import models from filer.fields.image import FilerImageField class Book(models.Model): title = models.CharField(max_length=255) cover = FilerImageField(related_name="book_covers", on_delete=models.CASCADE) back = FilerImageField(related_name="book_backs", on_delete=models.CASCADE) As with django.db.models.ForeignKey in general: You must specify an on_delete parameter to define what happens when the referenced file is deleted You have to define a non-clashing related_name if there are multiple ForeignKey s to the same model Common on_delete options: models.CASCADE - Delete the model containing the FilerFileField when the referenced file is deleted models.SET_NULL - Set the reference to NULL when the file is deleted (requires null=True) models.PROTECT - Prevent deletion of the referenced file templates django-filer plays well with easy_thumbnails . At the template level a FilerImageField can be used the same as a regular django.db.models.ImageField: {% load thumbnail %} {% thumbnail company.logo 250x250 crop %} admin The default widget provides a popup file selector that also directly supports uploading new images. Clicking on the magnifying glass will display the file selction popup. The red X will de-select the currently selected file (usefull if the field can be null). Warning Donâ€™t place a FilerFileField as the first field in admin. Django admin will try to set the focus to the first field in the form. But since the form field of FilerFileField is hidden that will cause in a javascript error. Document Extraction for Developers Transform docs into structured data with Sensible. Try for free â†’ Ads by EthicalAds Next Permissions Previous Upgrading Copyright Â© 2025, Stefan Foulis | Built with Sphinx and @pradyunsg's Furo theme. | Show Source CONTENTS FilerFileField and FilerImageField templates admin

django-filer 3.3.1 documentation Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Permissions Warning File download permissions are an experimental feature. The api may change at any time. By default files can be uploaded and managed by all staff members based on the standard django model permissions. Activating permission checking with the FILER_ENABLE_PERMISSIONS setting enables fine grained permissions based on individual folders. Permissions can be set in the â€œFolder permissionsâ€ section in Django admin. Note These permissions only concern editing files and folders in Django admin. All the files are still world downloadable by anyone who guesses the url. For real permission checks on downloads see the Secure Downloads section. Document Extraction for Developers Transform docs into structured data with Sensible. Try for free â†’ Ads by EthicalAds Next Secure Downloads Previous Usage Copyright Â© 2025, Stefan Foulis | Built with Sphinx and @pradyunsg's Furo theme. | Show Source

django-filer 3.3.1 documentation Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Secure Downloads Warning Secure downloads are experimental and the API may change at any time. Warning Server Backends currently only work with files in the local filesystem. Note For the impatient: set FILER_ENABLE_PERMISSIONS to True include filer.server.urls in the root urls.py without a prefix To be able to check permissions on the file downloads, a special view is used. The files are saved in a separate location outside of MEDIA_ROOT to prevent accidental serving. By default this is a directory called smedia that is located in the parent directory of MEDIA_ROOT. The smedia directory must NOT be served by the webserver directly, because that would bypass the permission checks. To hook up the view filer.server.urls needs to be included in the root urls.py: urlpatterns += [ url(r'^', include('filer.server.urls')), ] Files with restricted permissions need to be placed in a secure storage backend. Configure a secure storage backend in FILER_STORAGES or use the default. Warning The â€œPermissions disabledâ€ checkbox in the file detail view in Django admin controls in which storage backend the file is saved. In order for it to be protected, this field must not be checked. For images the permissions also extend to all generated thumbnails. By default files with permissions are served directly by the Django process (using the filer.server.backends.default.DefaultServer backend). That is acceptable in a development environment, but is very bad for performance and security in production. The private file view will serve the permission-checked media files by delegating to one of its server backends. The ones bundled with django-filer live in filer.server.backends and it is easy to create new ones. The default is filer.server.backends.default.DefaultServer. It is suitable for development and serves the file directly from django. More suitable for production are server backends that delegate the actual file serving to an upstream webserver. NginxXAccelRedirectServer location: filer.server.backends.nginx.NginxXAccelRedirectServer nginx docs about this stuff: http://wiki.nginx.org/XSendfile in settings.py: FILER_SERVERS = { 'private': { 'main': { 'ENGINE': 'filer.server.backends.nginx.NginxXAccelRedirectServer', 'OPTIONS': { 'location': '/path/to/smedia/filer', 'nginx_location': '/nginx_filer_private', }, }, 'thumbnails': { 'ENGINE': 'filer.server.backends.nginx.NginxXAccelRedirectServer', 'OPTIONS': { 'location': '/path/to/smedia/filer_thumbnails', 'nginx_location': '/nginx_filer_private_thumbnails', }, }, }, } nginx_location is the location directive where nginx â€œhidesâ€ permission-checked files from general access. A fitting nginx configuration might look something like this: location /nginx_filer_private/ { internal; alias /path/to/smedia/filer_private/; } location /nginx_filer_private_thumbnails/ { internal; alias /path/to/smedia/filer_private_thumbnails/; } Note make sure you follow the example exactly. Missing trailing slashes and alias vs. root have subtle differences that can make your config fail. NginxXAccelRedirectServer will add the a X-Accel-Redirect header to the response instead of actually loading and delivering the file itself. The value in the header will be something like /nginx_filer_private/2011/03/04/myfile.pdf. Nginx picks this up and does the actual file delivery while the django backend is free to do other stuff again. ApacheXSendfileServer location: filer.server.backends.xsendfile.ApacheXSendfileServer Warning I have not tested this myself. Any feedback and example configurations are very welcome :-) Once you have mod_xsendfile installed on your apache server you can configure the settings. in settings.py: FILER_SERVERS = { 'private': { 'main': { 'ENGINE': 'filer.server.backends.xsendfile.ApacheXSendfileServer', }, 'thumbnails': { 'ENGINE': 'filer.server.backends.xsendfile.ApacheXSendfileServer', }, }, } in your apache configuration: XSendFile On XSendFilePath /path/to/smedia/ XSendFilePath is a whitelist for directories where apache will serve files from. ClickSend SMS API. An easy, simple SMS API. ClickSend is made for developers. Try for free. Ads by EthicalAds Next Validation of uploaded files Previous Permissions Copyright Â© 2025, Stefan Foulis | Built with Sphinx and @pradyunsg's Furo theme. | Show Source CONTENTS NginxXAccelRedirectServer ApacheXSendfileServer

django-filer 3.3.1 documentation Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Settings FILER_ENABLE_PERMISSIONS Activate the or not the Permission check on the files and folders before displaying them in the admin. When set to False it gives all the authorization to staff members based on standard Django model permissions. Defaults to False FILER_IS_PUBLIC_DEFAULT Should newly uploaded files have permission checking disabled (be public) by default. Defaults to True (new files have permission checking disable, are public) FILER_STORAGES A dictionary to configure storage backends used for file storage. e.g: FILER_STORAGES = { 'public': { 'main': { 'ENGINE': 'filer.storage.PublicFileSystemStorage', 'OPTIONS': { 'location': '/path/to/media/filer', 'base_url': '/media/filer/', }, 'UPLOAD_TO': 'filer.utils.generate_filename.randomized', 'UPLOAD_TO_PREFIX': 'filer_public', }, 'thumbnails': { 'ENGINE': 'filer.storage.PublicFileSystemStorage', 'OPTIONS': { 'location': '/path/to/media/filer_thumbnails', 'base_url': '/media/filer_thumbnails/', }, }, }, 'private': { 'main': { 'ENGINE': 'filer.storage.PrivateFileSystemStorage', 'OPTIONS': { 'location': '/path/to/smedia/filer', 'base_url': '/smedia/filer/', }, 'UPLOAD_TO': 'filer.utils.generate_filename.randomized', 'UPLOAD_TO_PREFIX': 'filer_public', }, 'thumbnails': { 'ENGINE': 'filer.storage.PrivateFileSystemStorage', 'OPTIONS': { 'location': '/path/to/smedia/filer_thumbnails', 'base_url': '/smedia/filer_thumbnails/', }, }, }, } Defaults to FileSystemStorage in <MEDIA_ROOT>/filer_public/ and <MEDIA_ROOT>/filer_public_thumbnails/ for public files and <MEDIA_ROOT>/../smedia/filer_private/ and <MEDIA_ROOT>/../smedia/filer_private_thumbnails/ for private files. Public storage uses the default storageâ€™s backend. This is taken from Djangoâ€™s STORAGES setting if it exists or, if not, from the DEFAULT_FILE_STORAGE setting for compatibility with earlier Django versions (5.0 or below). UPLOAD_TO is the function to generate the path relative to the storage root. The default generates a random path like 1d/a5/1da50fee-5003-46a1-a191-b547125053a8/filename.jpg. This will be applied whenever a file is uploaded or moved between public (without permission checks) and private (with permission checks) storages. Defaults to 'filer.utils.generate_filename.randomized'. Overriding single keys is possible, for example just set your custom UPLOAD_TO: FILER_STORAGES = { 'public': { 'main': { 'UPLOAD_TO': 'my_package.generate_filer_filename.no_dirs', }, }, # same for private, or not } FILER_SERVERS Warning Server Backends are experimental and the API may change at any time. A dictionary to configure server backends to serve files with permissions. e.g: DEFAULT_FILER_SERVERS = { 'private': { 'main': { 'ENGINE': 'filer.server.backends.default.DefaultServer', }, 'thumbnails': { 'ENGINE': 'filer.server.backends.default.DefaultServer', } } } Defaults to using the DefaultServer (doh)! This will serve the files with the django app. FILER_PAGINATE_BY The number of items (Folders, Files) that should be displayed per page in admin. Defaults to 100 FILER_SUBJECT_LOCATION_IMAGE_DEBUG Draws a red circle around to point in the image that was used to do the subject location aware image cropping. Defaults to False FILER_ALLOW_REGULAR_USERS_TO_ADD_ROOT_FOLDERS Regular users are not allowed to create new folders at the root level, only subfolders of already existing folders, unless this setting is set to True. Defaults to False FILER_IMAGE_MODEL Defines the dotted path to a custom Image model; please include the model name. Example: â€˜my.app.models.CustomImageâ€™ Defaults to False FILER_CANONICAL_URL Defines the path element common to all canonical file URLs. Defaults to 'canonical/' FILER_UPLOADER_MAX_FILES Limit of files to upload by one drag and drop event. This is to avoid extensive accidental uploads, e.g. by dragging to root direcory onto an upload field. Defaults to 100. FILER_UPLOADER_CONNECTIONS Number of simultaneous AJAX uploads. Defaults to 3. If your database backend is SQLite it would be set to 1 by default. This allows to avoid database is locked errors on SQLite during multiple simultaneous file uploads. FILER_UPLOADER_MAX_FILE_SIZE Limits the maximal file size if set. Takes an integer (file size in MB). Defaults to None. FILER_MAX_IMAGE_PIXELS Limits the maximal pixel size of the image that can be uploaded to the Filer. It will also be lower than or equals to the MAX_IMAGE_PIXELS that Pillowâ€™s PIL allows. MAX_IMAGE_PIXELS = int(1024 * 1024 * 1024 // 4 // 3) Defaults to MAX_IMAGE_PIXELS. But when set, should always be lower than the MAX_IMAGE_PIXELS limit set by Pillow. This is useful setting to prevent decompression bomb DOS attack. FILER_ADD_FILE_VALIDATORS Dictionary that adds file upload validators for specific mime types. See Validation of uploaded files. FILER_REMOVE_FILE_VALIDATORS List of default file validators to be ignored. See Validation of uploaded files. ClickSend SMS API. An easy, simple SMS API. ClickSend is made for developers. Try for free. Ads by EthicalAds Next Development Previous Validation of uploaded files Copyright Â© 2025, Stefan Foulis | Built with Sphinx and @pradyunsg's Furo theme. | Show Source CONTENTS FILER_ENABLE_PERMISSIONS FILER_IS_PUBLIC_DEFAULT FILER_STORAGES FILER_SERVERS FILER_PAGINATE_BY FILER_SUBJECT_LOCATION_IMAGE_DEBUG FILER_ALLOW_REGULAR_USERS_TO_ADD_ROOT_FOLDERS FILER_IMAGE_MODEL FILER_CANONICAL_URL FILER_UPLOADER_MAX_FILES FILER_UPLOADER_CONNECTIONS FILER_UPLOADER_MAX_FILE_SIZE FILER_MAX_IMAGE_PIXELS FILER_ADD_FILE_VALIDATORS FILER_REMOVE_FILE_VALIDATORS

django-filer 3.3.1 documentation django-filer 3.3.1 documentation Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Extending Django FilerÂ¶ Django Filer ships with support for image files, and generic files (everything thatâ€™s not an image). So what if you wanted to add support for a particular kind of file thatsâ€™s not already included? Itâ€™s easy to extend it to do this, without needing to touch the Filerâ€™s code at all (and no-one wants to have to maintain fork if they can avoid it). So for example, you might want to be able to manage video files. You could of course simply store and file them as generic file types, but that might not be enough - perhaps your own application needs to know that certain files are in fact video files, so that it can treat them appropriately (process them, allow only them to be selected in certain widgets, and so on). In this example we will create support for video files. The modelÂ¶ The very basicsÂ¶ In your own application, you need to create a Video model. This model has to inherit from filer.models.filemodels.File. # import the File class to inherit from from filer.models.filemodels import File # we'll need to refer to filer settings from filer import settings as filer_settings class Video(File): pass # for now... When a file is uploaded, filer.admin.clipboardadmin.ClipboardAdmin.ajax_upload() loops over the different models in filer.settings.FILER_FILE_MODELS and calls its matches_file_type() to see if the file matches a known filename extension. When a match is found, the filer will create an instance of that class for the file. So letâ€™s add a matches_file_type() method to the Video model: @classmethod def matches_file_type(cls, iname, ifile, mime_type): video_types = ['application/vnd.dvb.ait', 'video/x-sgi-movie', 'video/mp4', 'video/mpeg', 'video/x-msvideo', 'video/x-ms-wmv', 'video/ogg', 'video/webm', 'video/quicktime'] return mime_type in video_types Note The signature of this classmethod changed in version 2.0. Now you can upload files of those types into the Filer. For each one you upload an instance of your Video class will be created. IconsÂ¶ At the moment, the files you upload will have the Filerâ€™s generic file icon - not very appropriate or helpful for video. What you need to do is add a suitable _icon attribute to the class. The filer.models.filemodels.File class weâ€™ve inherited from has an icons() property, from filer.models.mixins.IconsMixin. This checks for the _icon attribute; if it finds one, it uses it to build URLs for the icons in various different sizes. If _icons is video, a typical result might be /static/filer/icons/video_48x48.png. Of course, you can also create an icons() property specific to your new model. For example, filer.models.imagemodels.Image does that, so that it can create thumbnail icons for each file rather than a single icon for all of that type. In our Video model the simple case will do: # the icon it will use _icon = "video" And in fact, the Filer already has an icon that matches this - if there were not already a set of video icons in the Filerâ€™s static assets, weâ€™d have to provide them - see filer/static/icons for examples. The adminÂ¶ Now we need to register our new model with the admin. Again, the very simplest case: from django.contrib import admin from filer.admin.fileadmin import FileAdmin from models import Video admin.site.register(Video, FileAdmin) # use the standard FileAdmin â€¦ but of course if your model had particular fields of its own (as for example the Image model has a subject_location field) you would create your own ModelAdmin class for it, along with a form, special widgets and whatever else you needed. Using your new file typeÂ¶ Youâ€™ve now done enough to be able to get hold of files of your new kind in the admin (wherever the admin uses a FilerFileField) but to make it really useful we need to to a little more. For example, it might be useful to have: its own field type to get hold of it in some other model a special form for the field a widget for selecting it in the admin â€¦ and so on How you use it will be up to you, but a fairly typical use case would be in a django CMS plugin, and that is the example that will be followed here. Create a custom field for your file typeÂ¶ from filer.fields.file import FilerFileField class FilerVideoField(FilerFileField): default_model_class = Video Of course you could also create an admin widget and admin form, but itâ€™s not necessary at this stage - the ones generic files use will do just fine. Create some other model that uses itÂ¶ Here, itâ€™s going to be a django CMS plugin: from cms.models import CMSPlugin class VideoPluginEditor(CMSPlugin): video = FilerVideoField() # you'd probably want some other fields in practice... Youâ€™ll have to provide an admin class for your model; in this case, the admin will be provided as part of the django CMS plugin architecture. Note If you are not already familiar with the django CMS plugin architecture, http://docs.django-cms.org/en/latest/how_to/custom_plugins.html#overview will provide an explanation. from cms.plugin_base import CMSPluginBase from models import VideoPluginEditor class VideoPluginPublisher(CMSPluginBase): model = VideoPluginEditor render_template = "video/video.html" text_enabled = True admin_preview = False def icon_src(self, instance): return "/static/plugin_icons/video.png" def render(self, context, instance, placeholder): context.update({ 'video':instance, 'placeholder':placeholder, }) return context plugin_pool.register_plugin(VideoPluginPublisher) â€¦ and now, assuming you have created a suitable video/video.html, youâ€™ve got a working plugin that will make use of your new Filer file type. Other things you could addÂ¶ Admin templatingÂ¶ filer/templates/templates/admin/filer/folder lists the individual items in each folder. It checks item.file_type to determine how to display those items and what to display for them. You might want to extend this, so that the list includes the appropriate information for your new file type. In that case you will need to override the template, and in the Video model: # declare the file_type for the list template file_type = 'Video' Note that if you do this, you will need to override the template - otherwise your items will fail to display in the folder lists. Overriding the Directory Listing SearchÂ¶ By default, filer will search against name for Folders and name, description, and original_filename for Files, in addition to searching against the owner. If you are using auth.User as your User model, filer will search against the username, first_name, last_name, email fields. If you are using a custom User model, filer will search against all fields that are CharFields except for the password field. You can override this behavior by subclassing the filer.admin.folderadmin.FolderAdmin class and overriding the owner_search_fields property. # in an admin.py file from django.contrib import admin from filer.admin import FolderAdmin from filer.models import Folder class MyFolderAdmin(FolderAdmin): owner_search_fields = ['field1', 'field2'] admin.site.unregister(Folder) admin.site.register(Folder, FolderAdmin) You can also override the search behavior for Folders. Just override search_fields by subclassing the filer.admin.folderadmin.FolderAdmin. It works as described in Djangoâ€™s docs. E.g.: # in an admin.py file class MyFolderAdmin(FolderAdmin): search_fields = ['=field1', '^field2'] admin.site.unregister(Folder) admin.site.register(Folder, MyFolderAdmin) Providing custom Image modelÂ¶ As the Image model is special, a different way to implement custom Image model is required, which uses the Django swappable models interface. Defining the modelÂ¶ First a custom model must be defined; it should inherit from BaseImage, the basic abstract class: from filer.models.abstract.BaseImage class CustomImage(BaseImage): my_field = models.CharField(max_length=10) class Meta(BaseImage.Meta): # You must define a meta with en explicit app_label app_label = 'myapp' default_manager_name = 'objects' The model can be defined in any installed application declared after django-filer. BaseImage defines the following fields (plus the basic fields defined in File): default_alt_text default_caption subject_location you may add whatever fields you need, just like any other model. ..warning: app_label in Meta must be explicitly defined. Customize the adminÂ¶ If you added fields in your custom Image model, you have to customize the admin too: from django.contrib import admin from filer.admin.imageadmin import ImageAdmin Image = load_model(filer_settings.FILER_IMAGE_MODEL) class CustomImageAdmin(ImageAdmin): # your custom code pass # Using build_fieldsets allows to easily integrate common field in the admin # Don't define fieldsets in the ModelAdmin above and add the custom fields # to the ``extra_main_fields`` or ``extra_fieldsets`` as shown below CustomImageAdmin.fieldsets = CustomImageAdmin.build_fieldsets( extra_main_fields=('default_alt_text', 'default_caption', 'my_field'...), extra_fieldsets=( ('Subject Location', { 'fields': ('subject_location',), 'classes': ('collapse',), }), ) ) # Unregister the default admin admin.site.unregister(Image) # Register your own admin.site.register(Image, CustomImageAdmin) Swap the Image modelÂ¶ Set FILER_IMAGE_MODEL to the path of your custom model: FILER_IMAGE_MODEL = 'myapp.CustomImage' Next Running tests Previous Development Copyright Â© 2025, Stefan Foulis | Built with Sphinx and @pradyunsg's Furo theme. | Show Source Contents Extending Django Filer The model The very basics Icons The admin Using your new file type Create a custom field for your file type Create some other model that uses it Other things you could add Admin templating Overriding the Directory Listing Search Providing custom Image model Defining the model Customize the admin Swap the Image model

django-filer 3.3.1 documentation django-filer 3.3.1 documentation Installation and Configuration Upgrading Usage Permissions Secure Downloads Validation of uploaded files Settings Development Extending Django Filer Running tests Dump payload Management commands Management commandsÂ¶ Generating thumbnailsÂ¶ django-filer generates preview thumbnails of the images which are displayed in the admin. Usually these are generated on the fly when images are uploaded. If however you have imported the images programmatically you may want to generate the thumbnails eagerly utilizing a management command. To generate them, use: ./manage.py generate_thumbnails Filesystem ChecksÂ¶ django-filer offers a few commands to check the integrity of the database against the files stored on disk. By invoking: ./manage.py filer_check --missing all files which are referenced by the database, but missing on disk are reported. Invoking: ./manage.py filer_check --delete-missing deletes those file references from the database. Invoking: ./manage.py filer_check --orphans lists all files found on disk belonging to the configured storage engine, but which are not referenced by the database. Invoking: ./manage.py filer_check --delete-orphans deletes those orphaned files from disk. Previous Dump payload Copyright Â© 2025, Stefan Foulis | Built with Sphinx and @pradyunsg's Furo theme. | Show Source Contents Management commands Generating thumbnails Filesystem Checks